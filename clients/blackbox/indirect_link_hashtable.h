#ifndef INDIRECT_LINK_HASHTABLE_H
#define INDIRECT_LINK_HASHTABLE_H 1

/* This module maintains the IBP hashtable, which is visible from inside
 * the code cache via dcontext pointers. The table uses open-addressing,
 * and each entry is a hash of two BB tags with no payload:
 *
 *     entry = (from_tag << 1) ^ to_tag
 *
 * The table implementation is generated from the hashtablex.h template
 * in the DR core. This implementation requires a table end sentinel to
 * avoid looking up the table start address on loopback. Because our
 * entries have no payload, the each inserted value has the low bit
 * toggled on, so as to be distinct from NULL and the end sentinel:
 *
 *     NULL: 0x0
 *     END:  0x2
 *     value = entry | 0x1
 *
 * To maintain distribution of entries in the table, the hashtable key
 * is offset one bit. The hashtablex implementation automatically
 * analyzes the table on every insert and resizes it at the optimal
 * time. Standard read/write locks govern access to the hashtable
 * from C code, except that no lock is required for the remove()
 * operation, and (as best I understand it) remove() can safely
 * run in parallel with the assembly routine (generated by
 * indirect_link_observer).
 */

#include "crowd_safe_util.h"

/**** Public Functions ****/

void
ibp_hash_global_init(dcontext_t *dcontext);

/* Lookup an entry in the hashtable; delegates to template code.
 * Acquires and releases the table's read lock. */
bb_tag_pairing_t
ibp_hash_lookup(dcontext_t *dcontext, app_pc from, app_pc to);

/* Add an entry to the hashtable; delegates to template code.
 * Acquires and releases the table's write lock. */
bool
ibp_hash_add(dcontext_t *dcontext, app_pc from, app_pc to);

uint
get_ibp_edge_count(app_pc tag);

bool
ibp_has_incoming_edges(app_pc tag);

void
ibp_tag_remove(dcontext_t *dcontext, app_pc tag);

void
ibp_clear(dcontext_t *dcontext);

#ifdef MONITOR_UNEXPECTED_IBP
void
install_unexpected_ibp(dcontext_t *dcontext, app_pc from, app_pc to, module_location_t *from_module,
    module_location_t *to_module, bool is_from_expected, bool is_to_expected, uint edge_index, bool is_admitted, bool is_return);

bool
notify_possibly_unexpected_ibp(dcontext_t *dcontext, crowd_safe_thread_local_t *cstl,
    app_pc from, app_pc to, bool is_unexpected_return);

void
write_stale_uibp_reports(dcontext_t *dcontext, clock_type_t now);
#endif

#ifdef MONITOR_UNEXPECTED_IBP
void
write_final_uibp_report();
#endif

void
ibp_hash_global_destroy();

#endif
