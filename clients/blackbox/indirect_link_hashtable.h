#ifndef INDIRECT_LINK_HASHTABLE_H
#define INDIRECT_LINK_HASHTABLE_H 1

/* This module maintains the IBP hashtable, which is visible from inside
 * the code cache via dcontext pointers. The table uses open-addressing,
 * and each entry is a hash of two BB tags with no payload:
 *
 *     entry = (from_tag << 1) ^ to_tag
 *
 * The table implementation is generated from the hashtablex.h template
 * in the DR core. This implementation requires a table end sentinel to
 * avoid looking up the table start address on loopback. Because our
 * entries have no payload, the each inserted value has the low bit
 * toggled on, so as to be distinct from NULL and the end sentinel:
 *
 *     NULL: 0x0
 *     END:  0x2
 *     value = entry | 0x1
 *
 * To maintain distribution of entries in the table, the hashtable key
 * is offset one bit. The hashtablex implementation automatically
 * analyzes the table on every insert and resizes it at the optimal
 * time. Standard read/write locks govern access to the hashtable
 * from C code, except that no lock is required for the remove()
 * operation, and (as best I understand it) remove() can safely
 * run in parallel with the assembly routine (generated by
 * indirect_link_observer).
 */

#include "../../core/hashtable.h"
#include "crowd_safe_util.h"

/**** Public Types ****/

/* Distinct type for the pairing of two BB tags that comprises the
 * key for this hashtable. */
typedef uint64 bb_tag_pairing_t;

/**** hashtablex header template ****/

/* Used by the hashtablex template to name the hashtable functions. */
#define NAME_KEY ibp // "ibp" = "indirect branch path"

/* The entry type is just key, no payload. */
#define ENTRY_TYPE bb_tag_pairing_t

/* End sentinel is <1,0>
 * No collisions in x32
 * Collision occurs in x64 on { mask32(to) == 1, (mask32(from) ^ (mask32(to) <<o 1)) == 0 }
 *     => { mask32(to) == 1, mask32(from) == 2 }
 *     (quite unlikely, though possible) */
#define IBP_HASHTABLE_END_SENTINEL ((bb_tag_pairing_t)PC(0x100000000))

/* Identifies the function to free the payload. Ours points to an
 * empty function, since we do not have any payload. */
#define CUSTOM_FIELDS void (*free_payload_func)(void*);

#define DISABLE_STAT_STUDY 1
#define FAST_CLEAR 1

/* Request template header content. */
#define HASHTABLEX_HEADER 1
#include "../../core/hashtablex.h" /*** invoke the template ***/
#undef HASHTABLEX_HEADER

/**** Public Fields ****/

/**** Public Functions ****/

void
ibp_hash_global_init(dcontext_t *dcontext);

void
ibp_thread_init(dcontext_t *dcontext);

/* Lookup an entry in the hashtable; delegates to template code.
 * Acquires and releases the table's read lock. */
bb_tag_pairing_t
ibp_hash_lookup(dcontext_t *dcontext, app_pc from, app_pc to);

/* Add an entry to the hashtable; delegates to template code.
 * Acquires and releases the table's write lock. */
bool
ibp_hash_add(dcontext_t *dcontext, app_pc from, app_pc to);

uint
get_ibp_edge_count(app_pc tag);

bool
ibp_has_incoming_edges(app_pc tag);

void
ibp_tag_remove(dcontext_t *dcontext, app_pc tag);

void
ibp_clear(dcontext_t *dcontext);

#ifdef MONITOR_UNEXPECTED_IBP
void
install_unexpected_ibp(dcontext_t *dcontext, app_pc from, app_pc to, module_location_t *from_module,
    module_location_t *to_module, bool is_from_expected, bool is_to_expected, uint edge_index, bool is_admitted, bool is_return);

bool
notify_possibly_unexpected_ibp(dcontext_t *dcontext, crowd_safe_thread_local_t *cstl,
    app_pc from, app_pc to, bool is_unexpected_return);

void
write_stale_uibp_reports(dcontext_t *dcontext, clock_type_t now);
#endif

/* Required by the hashtablex template. */
int
ibp_hash_iterate_next(dcontext_t *dcontext, ibp_table_t *htable, int iter,
                          OUT bb_tag_pairing_t *key);

/* Required by the hashtablex template. Removes from the hashtable in a safe
 * way during iteration. Returns an updated iteration index to pass to
 * ibp_hash_iterate_next().
 */
int
ibp_hash_iterate_remove(dcontext_t *dcontext, ibp_table_t *htable, int iter,
                            bb_tag_pairing_t key);

#ifdef MONITOR_UNEXPECTED_IBP
void
write_final_uibp_report();
#endif

void
ibp_thread_exit(dcontext_t *dcontext);

void
ibp_hash_global_destroy();

#endif
